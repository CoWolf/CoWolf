package de.uni_stuttgart.iste.cowolf.model.lqn.analysis

import de.uni_stuttgart.iste.cowolf.model.LqnCore.DocumentRoot
import java.util.Map
import de.uni_stuttgart.iste.cowolf.model.LqnCore.SolverParamsType
import de.uni_stuttgart.iste.cowolf.model.LqnCore.ProcessorType
import de.uni_stuttgart.iste.cowolf.model.LqnCore.TaskType
import de.uni_stuttgart.iste.cowolf.model.LqnCore.EntryType

class LQNSolverFileStandardGenerator implements LQNSolverFileGenerator {
	
	override doGenerateLQNSolverFile(DocumentRoot root, Map<String, Object> parameters) {
		return '''«lqnStandardTemplate(root, parameters)»'''
	}
	
	def lqnStandardTemplate(DocumentRoot r, Map<String, Object> parameters)'''
		
		«processSolverParams(r.lqnModel.solverParams)»
		
		# Processor Information: No of processors or 0 (0 is better)
		P 0
		#p ProcessorName SchedDiscipline [multiplicity, default = 1]
		#                   [replication, default = 1]
		#	Discipline = f fifo|r random|p premptive|
		#			h hol or non-pre-empt|s proc-sharing
		#	multiplicity = m value (multiprocessor)|i (infinite)
		#       replication = r value
		«FOR p : r.lqnModel.processor»
		«processProcessor(p)»
		«ENDFOR»
		# End of Processor Information
		-1
		
		# Task Information: No of Tasks or 0
		T 0
		#t TaskName RefFlag EntryList -1 Processor [multiplicity, default = 1]
		#                      [replication, default = 1]
		#	RefFlag = r (reference or user)|n (other)
		#       r type accepts no requests, is a pure client task
		#	optional multiplicity = m value (multiprocessor)|i (infinite)
		#       optional replication count = r value
		«FOR t : r.lqnModel.eAllContents.filter(TaskType).toList»
		«processTask(t)»
		«ENDFOR»		
		# End of Task Information
		-1
		
		#Entry Information: No. of Entries or 0
		E 0
		«FOR e : r.lqnModel.eAllContents.filter(EntryType).toList»
		«processEntry(e)»
		«ENDFOR»
		#End of Entry Information
		-1
		
		#Optional section for definition of activities
		# One section for each task that has activities
		# T taskname
		# Section for activity parameters
		# each activity is defined like a one-phase entry, with no -1 at end
		# :
		# Section for precedence among activities
		# a1 -> a2 for sequence
		# a1 -> a2 & a3 ... AND-fork
		# a1 & a2 ... -> a3   AND join
		# a1 & a2 ... -> a3 & a4 ... AND join followed by AND fork
		# a1 -> a2 + a3
	'''
	
	def processSolverParams(SolverParamsType solverParams)'''
		G "LQN Model. Generated by CoWolf"
		#Convergence criterion, iteration limit, print interval, under-relax
		#Under-relaxation coefficient stabilizes the algorithm if less than 1
		«solverParams.convVal»
		«solverParams.itLimit»
		«solverParams.printInt»
		«solverParams.underrelaxCoeff»
		# End of General Information, -1 is the terminator
		-1	
	'''
	
	def processProcessor(ProcessorType processor)'''
		p «processor.name» «processor.scheduling» «processor.multiplicity»
	'''
	
	def processTask(TaskType task)'''
		t «task.id» «task.scheduling» «task.entry.join(" ")» -1 «ProcessorType.cast(task.eContainer).name» «task.multiplicity» «task.replication»		
	'''
	
	def processEntry(EntryType entry)'''
		# Entry parameters in three possible formats:
		# (1) ParameterToken EntryName value
		#	a entry open-arrival-rate
		#	A entry initial-activity-name
		# (2) ParameterToken EntryName Phase1value Phase2 Phase3 -1
		#    Tokens and Value Definitions are:
		#       s for HostServiceRequests for EntryName
		#       c for HostServiceCoefficientofVariation
		#       f for PhaseTypeFlag (0 for stochastic requests, 1 for deterministic)
		# (3) Entry-to-entry parameters in the format
		#    ParameterToken FromEntry ToEntry Phase1Value Phase2 Phase3 -1
		#    Tokens and Value definitions are:
		#       y for mean SynchronousCalls (no. of rendezvous)
		#       F for ProbForwarding (forward to this entry rather than replying)
		#       z for mean AsynchronousCalls (or no. of sned-no-reply messages)
		#       o for Fanout of calls (to replicated tasks)
		#       i for FanIn of calls (from replicated tasks)
		s users 0 56 0 -1
		y users connect 0 1 0 -1
		y users interact 0 6 0 -1
		y users disconnect 0 6 0 -1
		s connect 0.001 0 0 -1
		y connect netware 1 0 0 -1
		s interact 0.0014 0 0 -1
		y interact netware 1 0 0 -1
		y interact ccreq 0.1 0 0 -1
		y interact dbupdate 1.15 0 0 -1
		s disconnect 0.0001 0.0007 0 -1
		y disconnect netware 1 0 0 -1
		y disconnect dbupdate 1 0 0 -1
		s netware 0.0012 0 0 -1
		y netware reservDisk 1.5 0 0 -1
		s dbupdate 0.0085 0 0 -1
		y dbupdate dbDisk 2 0 0 -1
		s ccreq 3 0 0 -1
		s reservDisk 0.011 0 0 -1
		s dbDisk 0.011 0 0 -1
	'''
}